import { modernRAG } from './modernRAG';
import { smartChatbot } from './smartChatbot';
import { feedbackAnalytics } from './feedbackAnalytics';

interface ChatMessage {
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
}

interface EmotionalState {
  timestamp: string;
  sentiment: 'very_negative' | 'negative' | 'neutral' | 'positive' | 'very_positive';
  emotions: string[]; // e.g., ['anxious', 'sad', 'hopeful']
  intensity: number; // 1-10 scale
  message: string; // Original message for context
}

interface MoodTrend {
  direction: 'improving' | 'stable' | 'declining' | 'crisis';
  currentMood: number; // Average of last 3 states
  previousMood: number; // Average of 3 states before that
  changeRate: number; // How fast mood is changing
  alert: boolean; // True if deteriorating
}

interface ScheduledFollowUp {
  id: string;
  userId: string;
  topic: string;
  context: string; // What was mentioned
  scheduledFor: string; // ISO timestamp
  completed: boolean;
  originalMessage: string;
}

interface SafetyViolation {
  timestamp: string;
  type: 'crisis' | 'diagnosis_request' | 'medication_advice' | 'scope_violation' | 'harmful_content';
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  action: string; // What action was taken
}

interface UserState {
  userId: string;
  currentSessionId?: string; // Track current analytics session
  assignedVariants?: { [experimentName: string]: string }; // A/B test assignments
  demographics?: {
    age?: number;
    ethnicity?: string;
    location?: string;
  };
  preferences?: {
    communicationStyle?: string;
    topics?: string[];
  };
  mentalHealthHistory?: {
    primaryConcerns?: string[];
    triggeredTopics?: string[];
    previousCrisisFlags?: boolean;
  };
  emotionalHistory?: EmotionalState[]; // Track emotions over time
  lastMoodTrend?: MoodTrend;
  scheduledFollowUps?: ScheduledFollowUp[]; // Proactive check-ins
  lastWeeklySummary?: string; // When last summary was sent
  safetyViolations?: SafetyViolation[]; // Track safety incidents
  lastAIReminder?: string; // Last time user was reminded this is AI
  // Enhanced profile enrichment
  goalsAndChallenges?: {
    statedGoals?: string[];          // e.g., "manage anxiety", "improve sleep"
    currentChallenges?: string[];    // e.g., "job stress", "relationship issues"
    progress?: string[];              // Noted improvements
  };
  copingStrategies?: {
    whatWorks?: string[];             // e.g., "exercise", "journaling", "meditation"
    whatDoesntWork?: string[];        // e.g., "avoidance", "substance use"
    willingToTry?: string[];          // New strategies they're open to
  };
  triggersAndStressors?: {
    identified?: string[];            // e.g., "crowds", "deadlines", "family events"
    patterns?: string[];              // e.g., "worse on Mondays", "better after exercise"
  };
  supportSystem?: {
    hasProfessionalSupport?: boolean; // Therapist, counselor, etc.
    supportPeople?: string[];         // e.g., "best friend", "mom", "brother"
    supportGroups?: string[];         // e.g., "men's group", "church community"
    barriers?: string[];              // e.g., "stigma", "cost", "time", "distrust"
  };
  therapeuticPreferences?: {
    approaches?: string[];            // e.g., "CBT", "mindfulness", "talk therapy"
    avoidances?: string[];            // Things they don't want
    openTo?: string[];                // Willing to explore
  };
  culturalConsiderations?: {
    religiousBeliefs?: string;        // e.g., "Christian", "Muslim", "spiritual"
    culturalPractices?: string[];     // e.g., "prayer", "community gatherings"
    culturalIdentity?: string[];      // e.g., "Black American", "Caribbean", "African"
    languagePreferences?: string[];   // Communication style preferences
  };
  conversationSummary?: string; // Running summary of past sessions
  safetyFlags?: {
    crisisRisk?: boolean;
    lastCrisisCheck?: string;
  };
  lastUpdated: string;
}

// Multi-turn conversation flow tracking
interface ConversationFlow {
  userId: string;
  currentStage: 'opening' | 'listening' | 'clarifying' | 'educating' | 'suggesting' | 'committing' | 'closing';
  topic: string;
  turnsInCurrentStage: number;
  crisisLevel: 'none' | 'low' | 'medium' | 'high' | 'critical';
  crisisIndicators: string[];
  lastStageChange: string;
}

// Crisis escalation tracking
interface CrisisMonitor {
  userId: string;
  indicators: {
    timestamp: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    indicator: string;
  }[];
  escalationStage: 'validate' | 'assess' | 'resources' | 'immediate';
  needsProfessional: boolean;
}

export class ClaudeEnhancedChatbotService {
  private conversationHistory: Map<string, ChatMessage[]> = new Map();
  private userStates: Map<string, UserState> = new Map();
  private conversationFlows: Map<string, ConversationFlow> = new Map();
  private crisisMonitors: Map<string, CrisisMonitor> = new Map();
  private backendUrl: string;
  private isAIAvailable: boolean = false;
  private readonly MAX_RECENT_MESSAGES = 5; // Keep last 5 exchanges in full detail

  constructor() {
    // Use backend proxy instead of direct API calls
    this.backendUrl = import.meta.env.VITE_BACKEND_URL || 'http://localhost:3001';
    this.isAIAvailable = true; // Assume backend is available
    console.log(`Using backend proxy for Claude API calls at: ${this.backendUrl}`);
    
    // Test backend connectivity immediately
    this.testBackendConnection();
    
    // Load persisted user states from localStorage
    this.loadUserStates();
  }

  private async testBackendConnection(): Promise<void> {
    try {
      console.log('ðŸ” Testing backend connection...');
      const response = await fetch(`${this.backendUrl}/health`);
      if (response.ok) {
        console.log('âœ… Backend connection successful');
      } else {
        console.error(`âŒ Backend health check failed: ${response.status}`);
      }
    } catch (error) {
      console.error('âŒ Backend connection test failed:', error);
    }
  }

  // Load user states from localStorage
  private loadUserStates() {
    try {
      const saved = localStorage.getItem('amani_user_states');
      if (saved) {
        const parsed = JSON.parse(saved);
        this.userStates = new Map(Object.entries(parsed));
      }
    } catch (error) {
      console.error('Failed to load user states:', error);
    }
  }

  // Save user states to localStorage
  private saveUserStates() {
    try {
      const obj = Object.fromEntries(this.userStates);
      localStorage.setItem('amani_user_states', JSON.stringify(obj));
    } catch (error) {
      console.error('Failed to save user states:', error);
    }
  }

  // Get or create user state
  private getUserState(userId: string): UserState {
    if (!this.userStates.has(userId)) {
      this.userStates.set(userId, {
        userId,
        lastUpdated: new Date().toISOString()
      });
    }
    return this.userStates.get(userId)!;
  }

  // Update user state based on conversation patterns
  private updateUserState(userId: string, userMessage: string, patterns: any) {
    const state = this.getUserState(userId);
    const lowerMessage = userMessage.toLowerCase();
    
    // Update mental health history
    if (!state.mentalHealthHistory) {
      state.mentalHealthHistory = { primaryConcerns: [], triggeredTopics: [] };
    }
    
    // Track primary concerns
    const concerns = [];
    if (patterns.isDepression) concerns.push('depression');
    if (patterns.isAnxiety) concerns.push('anxiety');
    if (patterns.isTrauma) concerns.push('trauma');
    if (patterns.isRelationship) concerns.push('relationships');
    if (patterns.isJobLoss) concerns.push('job_loss');
    if (patterns.isWorkplace) concerns.push('work_stress');
    
    concerns.forEach(concern => {
      if (!state.mentalHealthHistory!.primaryConcerns!.includes(concern)) {
        state.mentalHealthHistory!.primaryConcerns!.push(concern);
      }
    });
    
    // Update safety flags
    if (patterns.isCrisis) {
      if (!state.safetyFlags) state.safetyFlags = {};
      state.safetyFlags.crisisRisk = true;
      state.safetyFlags.lastCrisisCheck = new Date().toISOString();
    }
    
    // Track emotional state
    this.trackEmotionalState(state, userMessage, patterns);
    
    // Extract goals and challenges
    this.extractGoalsAndChallenges(state, lowerMessage);
    
    // Extract coping strategies
    this.extractCopingStrategies(state, lowerMessage);
    
    // Extract triggers and stressors
    this.extractTriggersAndStressors(state, lowerMessage);
    
    // Extract support system info
    this.extractSupportSystem(state, lowerMessage);
    
    // Extract therapeutic preferences
    this.extractTherapeuticPreferences(state, lowerMessage);
    
    // Extract cultural considerations
    this.extractCulturalConsiderations(state, lowerMessage);
    
    state.lastUpdated = new Date().toISOString();
    this.saveUserStates();
  }

  // Analyze and track emotional state
  private trackEmotionalState(state: UserState, message: string, patterns: any) {
    if (!state.emotionalHistory) {
      state.emotionalHistory = [];
    }
    
    const emotionalState = this.analyzeEmotionalState(message, patterns);
    state.emotionalHistory.push(emotionalState);
    
    // Keep only last 30 emotional states (to track trends without bloat)
    if (state.emotionalHistory.length > 30) {
      state.emotionalHistory = state.emotionalHistory.slice(-30);
    }
    
    // Calculate and update mood trend
    if (state.emotionalHistory.length >= 3) {
      state.lastMoodTrend = this.calculateMoodTrend(state.emotionalHistory);
    }
  }

  // Analyze emotional state from message
  private analyzeEmotionalState(message: string, patterns: any): EmotionalState {
    const emotions: string[] = [];
    let sentimentScore = 0; // -2 to +2
    let intensity = 5; // 1-10
    
    // Detect emotions
    if (patterns.isAnxiety) {
      emotions.push('anxious');
      sentimentScore -= 1;
      intensity += 2;
    }
    if (patterns.isDepression) {
      emotions.push('depressed');
      sentimentScore -= 1.5;
      intensity += 2;
    }
    if (patterns.isCrisis) {
      emotions.push('crisis');
      sentimentScore -= 2;
      intensity = 10;
    }
    if (patterns.isAnger) {
      emotions.push('angry');
      sentimentScore -= 1;
      intensity += 1;
    }
    if (patterns.isPositiveEmotion) {
      emotions.push('happy');
      sentimentScore += 1.5;
      intensity -= 1;
    }
    if (patterns.isFatigue) {
      emotions.push('exhausted');
      sentimentScore -= 0.5;
    }
    if (patterns.isLoneliness) {
      emotions.push('lonely');
      sentimentScore -= 1;
    }
    if (patterns.isTrauma) {
      emotions.push('traumatized');
      sentimentScore -= 1.5;
      intensity += 2;
    }
    if (patterns.isGratitude) {
      emotions.push('grateful');
      sentimentScore += 1;
    }
    
    // Determine sentiment category
    let sentiment: EmotionalState['sentiment'];
    if (sentimentScore <= -1.5) sentiment = 'very_negative';
    else if (sentimentScore <= -0.5) sentiment = 'negative';
    else if (sentimentScore >= 1.5) sentiment = 'very_positive';
    else if (sentimentScore >= 0.5) sentiment = 'positive';
    else sentiment = 'neutral';
    
    // Cap intensity
    intensity = Math.max(1, Math.min(10, intensity));
    
    return {
      timestamp: new Date().toISOString(),
      sentiment,
      emotions,
      intensity,
      message: message.substring(0, 100) // Store snippet for context
    };
  }

  // Calculate mood trend from emotional history
  private calculateMoodTrend(emotionalHistory: EmotionalState[]): MoodTrend {
    if (emotionalHistory.length < 6) {
      return {
        direction: 'stable',
        currentMood: 0,
        previousMood: 0,
        changeRate: 0,
        alert: false
      };
    }
    
    // Convert sentiment to numeric value
    const sentimentToValue = (sentiment: EmotionalState['sentiment']): number => {
      const map = {
        'very_negative': -2,
        'negative': -1,
        'neutral': 0,
        'positive': 1,
        'very_positive': 2
      };
      return map[sentiment];
    };
    
    // Get recent 3 and previous 3 emotional states
    const recent = emotionalHistory.slice(-3);
    const previous = emotionalHistory.slice(-6, -3);
    
    const currentMood = recent.reduce((sum, state) => sum + sentimentToValue(state.sentiment), 0) / 3;
    const previousMood = previous.reduce((sum, state) => sum + sentimentToValue(state.sentiment), 0) / 3;
    
    const changeRate = currentMood - previousMood;
    
    // Determine trend direction
    let direction: MoodTrend['direction'];
    let alert = false;
    
    if (changeRate <= -1) {
      direction = 'declining';
      alert = true; // Alert on significant decline
    } else if (changeRate <= -0.3) {
      direction = 'declining';
    } else if (changeRate >= 1) {
      direction = 'improving';
    } else if (changeRate >= 0.3) {
      direction = 'improving';
    } else {
      direction = 'stable';
    }
    
    // Check for crisis pattern
    const hasCrisis = recent.some(state => state.emotions.includes('crisis'));
    if (hasCrisis || currentMood <= -1.5) {
      direction = 'crisis';
      alert = true;
    }
    
    return {
      direction,
      currentMood,
      previousMood,
      changeRate,
      alert
    };
  }

  // Get mood trend guidance for AI
  private getMoodTrendGuidance(trend?: MoodTrend): string {
    if (!trend) return '';
    
    if (trend.direction === 'crisis') {
      return 'ðŸš¨ CRISIS ALERT: User\'s emotional state is in crisis territory. Priority: safety and resources.';
    } else if (trend.direction === 'declining' && trend.alert) {
      return 'âš ï¸ MOOD ALERT: User\'s mood has significantly declined over recent messages. Check in gently: "I notice you seem to be struggling more lately. What\'s changed?"';
    } else if (trend.direction === 'declining') {
      return 'ðŸ“‰ User\'s mood trending downward. Be extra supportive and ask if they need additional help.';
    } else if (trend.direction === 'improving') {
      return 'ðŸ“ˆ POSITIVE TREND: User\'s mood is improving! Celebrate progress: "I notice things seem a bit better. What\'s been helping?"';
    } else {
      return 'ðŸ“Š Mood is stable. Continue supportive conversation.';
    }
  }

  // Detect if message contains a future event worth following up on
  private detectFollowUpOpportunity(userId: string, message: string): void {
    const state = this.getUserState(userId);
    if (!state.scheduledFollowUps) {
      state.scheduledFollowUps = [];
    }

    // Detect future events/conversations
    const futureEventPatterns = [
      { pattern: /(?:have|having|got) (?:a|an) (?:interview|job interview|meeting|appointment|conversation|talk|discussion) (?:tomorrow|next week|monday|tuesday|wednesday|thursday|friday|this week|coming up|soon)/i, topic: 'upcoming_event', daysUntil: 1 },
      { pattern: /(?:going to|planning to|need to|have to) (?:talk to|speak to|confront|meet with|see) (?:my |the )?(?:boss|manager|partner|wife|girlfriend|boyfriend|therapist|doctor)/i, topic: 'important_conversation', daysUntil: 2 },
      { pattern: /(?:therapy|counseling|appointment|session) (?:tomorrow|next week|coming up|scheduled)/i, topic: 'therapy_session', daysUntil: 1 },
      { pattern: /(?:starting|beginning) (?:new job|new position|therapy|medication|treatment)/i, topic: 'new_beginning', daysUntil: 3 }
    ];

    futureEventPatterns.forEach(({ pattern, topic, daysUntil }) => {
      if (pattern.test(message)) {
        const followUpDate = new Date();
        followUpDate.setDate(followUpDate.getDate() + daysUntil);
        
        const followUp: ScheduledFollowUp = {
          id: `followup_${Date.now()}`,
          userId,
          topic,
          context: message.substring(0, 200),
          scheduledFor: followUpDate.toISOString(),
          completed: false,
          originalMessage: message
        };
        
        if (!state.scheduledFollowUps) {
          state.scheduledFollowUps = [];
        }
        state.scheduledFollowUps.push(followUp);
        console.log(`ðŸ“… Scheduled follow-up for ${topic} on ${followUpDate.toLocaleDateString()}`);
      }
    });

    this.saveUserStates();
  }

  // Check for pending follow-ups and generate proactive check-in
  private checkForPendingFollowUps(userId: string): string | null {
    const state = this.getUserState(userId);
    if (!state.scheduledFollowUps || state.scheduledFollowUps.length === 0) {
      return null;
    }

    const now = new Date();
    const pendingFollowUps = state.scheduledFollowUps.filter(f => 
      !f.completed && new Date(f.scheduledFor) <= now
    );

    if (pendingFollowUps.length === 0) return null;

    // Get the most recent pending follow-up
    const followUp = pendingFollowUps[0];
    
    // Mark as completed
    followUp.completed = true;
    this.saveUserStates();

    // Generate contextual follow-up message
    const followUpMessages: { [key: string]: string } = {
      'upcoming_event': `Hey, you mentioned having something important coming up. How did it go?`,
      'important_conversation': `You were going to have that conversation. How did it turn out?`,
      'therapy_session': `How was your therapy session?`,
      'new_beginning': `You were starting something new. How's it going so far?`
    };

    return followUpMessages[followUp.topic] || `How did that thing you mentioned go?`;
  }

  // Generate weekly mood summary
  private generateWeeklySummary(userId: string): string | null {
    const state = this.getUserState(userId);
    
    // Check if a week has passed since last summary
    if (state.lastWeeklySummary) {
      const lastSummary = new Date(state.lastWeeklySummary);
      const daysSince = (Date.now() - lastSummary.getTime()) / (1000 * 60 * 60 * 24);
      if (daysSince < 7) return null;
    }

    if (!state.emotionalHistory || state.emotionalHistory.length < 5) {
      return null; // Not enough data
    }

    // Get last 7 days of emotional data
    const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
    const weeklyStates = state.emotionalHistory.filter(s => 
      new Date(s.timestamp) >= weekAgo
    );

    if (weeklyStates.length === 0) return null;

    // Calculate weekly averages
    const avgSentiment = weeklyStates.reduce((sum, s) => {
      const val = { 'very_negative': -2, 'negative': -1, 'neutral': 0, 'positive': 1, 'very_positive': 2 }[s.sentiment];
      return sum + val;
    }, 0) / weeklyStates.length;

    // Get most common emotions
    const emotionCounts = new Map<string, number>();
    weeklyStates.forEach(s => {
      s.emotions.forEach(e => {
        emotionCounts.set(e, (emotionCounts.get(e) || 0) + 1);
      });
    });

    const topEmotions = Array.from(emotionCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([emotion]) => emotion);

    // Generate summary message
    let summary = `ðŸ“Š **Your Week in Review**\n\n`;
    
    if (avgSentiment >= 0.5) {
      summary += `Overall, you've had a positive week! `;
    } else if (avgSentiment >= -0.5) {
      summary += `This week has been mixed. `;
    } else {
      summary += `This week has been tough. `;
    }

    if (topEmotions.length > 0) {
      summary += `You've been feeling mostly: ${topEmotions.join(', ')}. `;
    }

    if (state.lastMoodTrend?.direction === 'improving') {
      summary += `The good news? Things seem to be getting better. ðŸ’ª`;
    } else if (state.lastMoodTrend?.direction === 'declining') {
      summary += `I've noticed things seem harder lately. Want to talk about it?`;
    }

    // Update last summary timestamp
    state.lastWeeklySummary = new Date().toISOString();
    this.saveUserStates();

    return summary;
  }

  // Generate personalized recommendations based on user profile
  private generatePersonalizedRecommendations(state: UserState): string {
    let recommendations = '';
    const concerns = state.mentalHealthHistory?.primaryConcerns || [];
    const whatWorks = state.copingStrategies?.whatWorks || [];
    const barriers = state.supportSystem?.barriers || [];
    
    // Resource recommendations based on primary concerns
    if (concerns.includes('anxiety') || concerns.includes('stress')) {
      recommendations += '\nðŸ’¡ Resources: Check out our mindfulness exercises in Mental Health Resources > Self-Care';
      
      if (!whatWorks.includes('meditation') && !state.copingStrategies?.whatDoesntWork?.includes('meditation')) {
        recommendations += '\nðŸ§˜ Technique: Try the 5-4-3-2-1 grounding technique (5 things you see, 4 you hear, 3 you touch, 2 you smell, 1 you taste)';
      }
    }
    
    if (concerns.includes('depression')) {
      recommendations += '\nðŸ“ Tool: Have you tried the Personal Journal feature? Writing can help process emotions';
      
      if (!state.supportSystem?.hasProfessionalSupport && !barriers.includes('stigma')) {
        recommendations += '\nðŸ¥ Consider: Talking to a therapist can make a real difference. Check Mental Health Resources for options';
      }
    }
    
    if (concerns.includes('relationships')) {
      recommendations += '\nðŸ’¬ Community: Check out Community Discussions > Relationships to connect with others going through similar things';
    }
    
    if (concerns.includes('work_stress')) {
      recommendations += '\nðŸ’¬ Community: Join the Work & Career discussions to get advice from others who get it';
    }
    
    // Coping technique suggestions based on what works
    if (whatWorks.includes('exercise') || whatWorks.includes('gym')) {
      recommendations += '\nðŸ’ª Since exercise helps you, try to get moving when stress hits - even a 10-minute walk counts';
    }
    
    if (whatWorks.includes('prayer') || state.culturalConsiderations?.religiousBeliefs) {
      recommendations += '\nðŸ™ Your faith is a strength - consider connecting with faith-based mental health support';
    }
    
    // Professional support recommendations
    if (!state.supportSystem?.hasProfessionalSupport && concerns.length >= 2) {
      if (barriers.includes('can\'t afford') || barriers.includes('too expensive')) {
        recommendations += '\nðŸ’° Free/low-cost options: Many therapists offer sliding scale fees. Check our resources for affordable options';
      } else if (barriers.includes('don\'t trust')) {
        recommendations += '\nðŸ¤ Finding the right fit matters. Look for therapists who specialize in working with Black men';
      }
    }
    
    // Community discussion suggestions
    const recurringTopics = this.getRecurringPatterns(state);
    if (recurringTopics.length > 0) {
      recommendations += `\nðŸ’¬ Connect: Others are discussing ${recurringTopics[0]} in Community Discussions`;
    }
    
    return recommendations;
  }

  // Check for scope violations (diagnosis requests, medication advice, etc.)
  private checkScopeViolations(userMessage: string): SafetyViolation | null {
    const lowerMessage = userMessage.toLowerCase();
    
    // Diagnosis requests
    const diagnosisPatterns = [
      /do i have|am i|is this|could this be|think i have|diagnosed with|is it/i,
      /depression|bipolar|schizophrenia|ptsd|ocd|adhd|autism|bpd|personality disorder/i
    ];
    
    const isDiagnosisRequest = diagnosisPatterns.every(p => p.test(lowerMessage)) &&
      /(?:do i have|am i|is this|could this be|think i have)/i.test(lowerMessage);
    
    if (isDiagnosisRequest) {
      return {
        timestamp: new Date().toISOString(),
        type: 'diagnosis_request',
        severity: 'medium',
        message: userMessage.substring(0, 200),
        action: 'Redirected to professional evaluation'
      };
    }
    
    // Medication advice requests
    const medicationPatterns = [
      /should i take|can i take|what medication|which medication|prescribe|prescription|dosage|side effects of/i,
      /prozac|zoloft|lexapro|xanax|ativan|klonopin|wellbutrin|cymbalta|effexor|antidepressant|anti-anxiety|ssri|benzodiazepine/i
    ];
    
    const isMedicationRequest = medicationPatterns.some(p => p.test(lowerMessage)) &&
      /(?:should i|can i|what|which|how much)/i.test(lowerMessage);
    
    if (isMedicationRequest) {
      return {
        timestamp: new Date().toISOString(),
        type: 'medication_advice',
        severity: 'high',
        message: userMessage.substring(0, 200),
        action: 'Redirected to medical professional'
      };
    }
    
    // Harmful content (encouraging harm to self or others)
    if (/(?:how to|ways to|methods to|best way to) (?:kill|hurt|harm|end|commit suicide)/i.test(lowerMessage)) {
      return {
        timestamp: new Date().toISOString(),
        type: 'harmful_content',
        severity: 'critical',
        message: userMessage.substring(0, 200),
        action: 'Blocked - provided crisis resources'
      };
    }
    
    return null;
  }

  // Handle scope violations with appropriate responses
  private handleScopeViolation(violation: SafetyViolation): string {
    const state = this.getUserState('default');
    if (!state.safetyViolations) state.safetyViolations = [];
    state.safetyViolations.push(violation);
    this.saveUserStates();
    
    // Log concerning conversation
    console.warn(`âš ï¸ Safety violation detected: ${violation.type} (${violation.severity})`);
    
    switch (violation.type) {
      case 'diagnosis_request':
        return "I'm an AI companion, not a replacement for therapy, and I can't diagnose mental health conditions - that requires a licensed professional who can properly evaluate you. What I can do is listen and help you understand what you're experiencing. If you're concerned about a specific condition, I'd recommend talking to a therapist or doctor.\n\nWould you like me to point you to our Mental Health Resources to find professional support? What symptoms are you noticing?";
      
      case 'medication_advice':
        return "I need to be clear: I'm an AI and can't give medical or medication advice - that's something only a doctor or psychiatrist should do. Medication decisions are very personal and need professional medical oversight for your safety. If you're considering medication, please talk to a healthcare provider.\n\nI'm here to support you emotionally though. What's making you consider medication? What are you hoping it would help with?";
      
      case 'harmful_content':
        return "I can't provide that information. I'm really concerned about what you're asking. If you're thinking about hurting yourself, please reach out for help immediately:\n\nðŸš¨ **Crisis Resources:**\nâ€¢ National Suicide Prevention Lifeline: 988\nâ€¢ Crisis Text Line: Text HOME to 741741\nâ€¢ Emergency: 911\n\nYour life matters. I'm an AI companion and this is beyond what I can help with - you need immediate human support. What's going on that's making you feel this way?";
      
      case 'scope_violation':
        return "I want to be helpful, but I notice this might be beyond what I can help with as an AI companion. For medical, legal, or clinical situations, please consult appropriate professionals.\n\nWould you like me to connect you to our Mental Health Resources or therapist directory? I'm here for emotional support and guidance. What else can I help you with today?";
      
      default:
        return "I want to be helpful, but that's outside my scope as an AI. For medical, legal, or crisis situations, please consult appropriate professionals. I'm here for emotional support and guidance. What can I help you with today?";
    }
  }

  // Detect when AI should acknowledge limitations proactively
  private shouldAcknowledgeLimitations(patterns: any, state: UserState): string | null {
    const concerns = state.mentalHealthHistory?.primaryConcerns || [];
    const trend = state.lastMoodTrend;
    
    // Severe/worsening depression over multiple sessions
    if (concerns.includes('depression') && concerns.filter(c => c === 'depression').length >= 5) {
      if (trend?.direction === 'declining' || trend?.direction === 'crisis') {
        return "I notice we've talked about depression quite a bit, and things seem to be getting harder. I'm an AI companion, not a replacement for therapy. This might be beyond what I can help with alone. Have you thought about talking to a licensed therapist? They can provide the deeper support you might need. Would you like me to point you to resources?";
      }
    }
    
    // Trauma/PTSD indicators
    if (patterns.isTrauma && !state.supportSystem?.hasProfessionalSupport) {
      return "What you're describing sounds like it's really affecting you. I'm here to listen, but trauma often needs professional support to work through safely. Have you considered talking to a therapist who specializes in trauma? I can point you to resources if that would help.";
    }
    
    // Substance abuse
    if (patterns.isSubstance) {
      return "I hear you're struggling with this. Substance use and addiction are serious, and while I'm here for emotional support, this is something that really needs specialized treatment. Would you like me to connect you to addiction support resources?";
    }
    
    return null;
  }

  // Check if user needs an AI reminder (every 20 messages or once per day)
  private needsAIReminder(userId: string, messageCount: number): boolean {
    const state = this.getUserState(userId);
    
    // Every 20 messages
    if (messageCount > 0 && messageCount % 20 === 0) return true;
    
    // Or once per day
    if (state.lastAIReminder) {
      const lastReminder = new Date(state.lastAIReminder);
      const hoursSince = (Date.now() - lastReminder.getTime()) / (1000 * 60 * 60);
      if (hoursSince >= 24) return true;
    } else {
      // First time user
      if (messageCount === 5) return true;
    }
    
    return false;
  }

  // Generate AI reminder disclaimer
  private generateAIReminder(userId: string): string {
    const state = this.getUserState(userId);
    state.lastAIReminder = new Date().toISOString();
    this.saveUserStates();
    
    return "\n\n---\nðŸ’­ *Reminder: I'm an AI mental health companion, not a replacement for professional therapy. If you need immediate help or clinical treatment, please reach out to a licensed professional.*";
  }

  // Export safety logs for review (admin/developer use)
  public exportSafetyLogs(): SafetyViolation[] {
    const allViolations: SafetyViolation[] = [];
    
    this.userStates.forEach(state => {
      if (state.safetyViolations && state.safetyViolations.length > 0) {
        allViolations.push(...state.safetyViolations);
      }
    });
    
    // Sort by timestamp (most recent first)
    return allViolations.sort((a, b) => 
      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
    );
  }

  // Get safety statistics
  public getSafetyStats(): {
    totalViolations: number;
    crisisCount: number;
    diagnosisRequests: number;
    medicationRequests: number;
    harmfulContent: number;
    last24Hours: number;
  } {
    const logs = this.exportSafetyLogs();
    const last24Hours = logs.filter(v => {
      const hoursSince = (Date.now() - new Date(v.timestamp).getTime()) / (1000 * 60 * 60);
      return hoursSince <= 24;
    });
    
    return {
      totalViolations: logs.length,
      crisisCount: logs.filter(v => v.type === 'crisis').length,
      diagnosisRequests: logs.filter(v => v.type === 'diagnosis_request').length,
      medicationRequests: logs.filter(v => v.type === 'medication_advice').length,
      harmfulContent: logs.filter(v => v.type === 'harmful_content').length,
      last24Hours: last24Hours.length
    };
  }

  // Start analytics session for user
  private startAnalyticsSession(userId: string): string {
    const state = this.getUserState(userId);
    
    if (!state.currentSessionId) {
      state.currentSessionId = feedbackAnalytics.startSession(userId);
      this.saveUserStates();
    }
    
    return state.currentSessionId;
  }

  // Update session metrics
  private _updateSessionMetrics(userId: string, topic?: string): void {
    const state = this.getUserState(userId);
    
    if (state.currentSessionId) {
      const updates: any = {
        messageCount: (state.emotionalHistory?.length || 0)
      };
      
      if (topic && !state.mentalHealthHistory?.primaryConcerns?.includes(topic)) {
        updates.topicsDiscussed = [...(state.mentalHealthHistory?.primaryConcerns || []), topic];
      }
      
      feedbackAnalytics.updateSession(state.currentSessionId, updates);
    }
  }

  // End session with completion type
  public endUserSession(userId: string, completionType: 'natural' | 'crisis_redirect' | 'abandoned' | 'resource_redirect'): void {
    const state = this.getUserState(userId);
    
    if (state.currentSessionId) {
      feedbackAnalytics.endSession(state.currentSessionId, completionType);
      state.currentSessionId = undefined;
      this.saveUserStates();
    }
  }

  // Record resource shown and potentially clicked
  public trackResource(userId: string, resourceType: 'crisis' | 'therapy' | 'addiction' | 'trauma' | 'general', resourceName: string, context: string): void {
    const state = this.getUserState(userId);
    
    if (state.currentSessionId) {
      feedbackAnalytics.recordResourceShown({
        resourceType,
        resourceName,
        userId,
        conversationContext: context,
        sessionId: state.currentSessionId
      });
    }
  }

  // Get A/B test variant for user
  private _getABTestVariant(userId: string, experimentName: string): string | null {
    const state = this.getUserState(userId);
    
    // Check if already assigned
    if (state.assignedVariants?.[experimentName]) {
      return state.assignedVariants[experimentName];
    }
    
    // Assign new variant
    const variant = feedbackAnalytics.assignVariant(experimentName, userId);
    
    if (variant) {
      if (!state.assignedVariants) state.assignedVariants = {};
      state.assignedVariants[experimentName] = variant.variantId;
      this.saveUserStates();
      return variant.variantId;
    }
    
    return null;
  }

  // Provide resource connection message with transparency
  private _getResourceConnectionMessage(resourceType: 'therapy' | 'crisis' | 'addiction' | 'trauma'): string {
    const baseMessage = "I'm an AI companion, not a replacement for therapy. ";
    
    const resources: { [key: string]: string } = {
      therapy: `${baseMessage}This sounds like something a licensed therapist could really help with.

ðŸ“‹ **Finding a Therapist:**
â€¢ Psychology Today: psychologytoday.com/us/therapists
â€¢ Therapy for Black Girls: therapyforblackgirls.com
â€¢ National Queer & Trans Therapists of Color Network: nqttcn.com
â€¢ Your health insurance provider's directory

Would you like to explore our Mental Health Resources section for more options?`,

      crisis: `${baseMessage}This is a crisis situation that needs immediate human support.

ðŸš¨ **Crisis Resources:**
â€¢ National Suicide Prevention Lifeline: 988
â€¢ Crisis Text Line: Text HOME to 741741
â€¢ Emergency Services: 911
â€¢ SAMHSA National Helpline: 1-800-662-4357

Please reach out right now. Your life matters.`,

      addiction: `${baseMessage}Substance use and addiction need specialized treatment for the best outcomes.

ðŸ¥ **Addiction Support:**
â€¢ SAMHSA National Helpline: 1-800-662-4357 (24/7, free, confidential)
â€¢ AA Meetings: aa.org
â€¢ NA Meetings: na.org
â€¢ Your doctor can refer you to addiction specialists

Would you like to talk about what's been going on?`,

      trauma: `${baseMessage}Trauma often needs professional support to process safely.

ðŸ©º **Trauma-Informed Care:**
â€¢ Find trauma therapists: psychologytoday.com
â€¢ RAINN (Sexual Assault): 1-800-656-4673
â€¢ Veterans Crisis Line: 988 (press 1)
â€¢ Your primary care doctor can provide referrals

I'm here to listen, but a trauma specialist can provide the deeper healing support you deserve.`
    };
    
    return resources[resourceType] || resources.therapy;
  }

  // Get contextual therapeutic tools based on current emotional state
  private getContextualTherapeuticTools(patterns: any, emotionalState?: EmotionalState): string {
    let tools = '';
    
    // Breathing exercises for anxiety/panic
    if (patterns.isAnxiety) {
      tools += '\n\nðŸ« **Quick Breathing Exercise**\nTry this right now:\n';
      tools += '1. Breathe in slowly through your nose for 4 counts\n';
      tools += '2. Hold for 4 counts\n';
      tools += '3. Breathe out through your mouth for 6 counts\n';
      tools += '4. Repeat 3-4 times\n';
      tools += 'This activates your calm response.';
    }
    
    // Grounding techniques for dissociation, panic, or high intensity
    if ((patterns.isTrauma || patterns.isAnxiety) && emotionalState?.intensity && emotionalState.intensity >= 7) {
      tools += '\n\nðŸ§  **Grounding Technique - 5-4-3-2-1**\nIf you\'re feeling overwhelmed right now:\n';
      tools += 'â€¢ Name 5 things you can SEE\n';
      tools += 'â€¢ Name 4 things you can TOUCH\n';
      tools += 'â€¢ Name 3 things you can HEAR\n';
      tools += 'â€¢ Name 2 things you can SMELL\n';
      tools += 'â€¢ Name 1 thing you can TASTE\n';
      tools += 'This brings you back to the present moment.';
    }
    
    // Journaling prompts for depression or emotional processing
    if (patterns.isDepression || patterns.isGeneralEmotional) {
      const journalPrompts = [
        'What am I feeling right now, and where do I feel it in my body?',
        'What triggered this feeling today?',
        'What\'s one small thing I can do for myself right now?',
        'If I could tell someone how I really feel, what would I say?',
        'What do I need most in this moment?'
      ];
      const randomPrompt = journalPrompts[Math.floor(Math.random() * journalPrompts.length)];
      tools += `\n\nðŸ“ **Journal Prompt**\nTry writing about: "${randomPrompt}"\n`;
      tools += 'Use the Personal Journal feature to track your thoughts.';
    }
    
    // Mood tracking integration
    if (patterns.isDepression || patterns.isAnxiety || patterns.isGeneralEmotional) {
      tools += '\n\nðŸ“Š **Track Your Mood**\n';
      tools += 'Use "How Are You Feeling?" to log your current mood.\n';
      tools += 'Tracking patterns helps you see what\'s helping and what\'s not.';
    }
    
    return tools;
  }

  // Load mood data from Feeling Check-in feature
  private loadMoodCheckInData(_userId: string): { recentMoods: number[], avgMood: number } | null {
    try {
      const moodHistory = localStorage.getItem('mood-history');
      if (!moodHistory) return null;
      
      const history = JSON.parse(moodHistory);
      const recentMoods = history.slice(0, 7).map((entry: any) => entry.mood);
      const avgMood = recentMoods.length > 0 
        ? recentMoods.reduce((sum: number, m: number) => sum + m, 0) / recentMoods.length 
        : 0;
      
      return { recentMoods, avgMood };
    } catch (error) {
      return null;
    }
  }

  // Generate contextual journal prompt based on conversation
  private _getContextualJournalPrompt(patterns: any, concerns: string[]): string {
    // Anxiety-focused prompts
    if (patterns.isAnxiety || concerns.includes('anxiety')) {
      const anxietyPrompts = [
        'What situations make me most anxious, and what patterns do I notice?',
        'When I feel anxious, what physical sensations do I notice?',
        'What has helped me manage anxiety in the past?',
        'What would I say to a friend who was feeling this anxious?'
      ];
      return anxietyPrompts[Math.floor(Math.random() * anxietyPrompts.length)];
    }
    
    // Depression-focused prompts
    if (patterns.isDepression || concerns.includes('depression')) {
      const depressionPrompts = [
        'Even on hard days, what are three small things I\'m grateful for?',
        'What does self-compassion look like for me today?',
        'If I had more energy, what would I want to do?',
        'What would make today 1% better?'
      ];
      return depressionPrompts[Math.floor(Math.random() * depressionPrompts.length)];
    }
    
    // Relationship-focused prompts
    if (patterns.isRelationship || concerns.includes('relationships')) {
      const relationshipPrompts = [
        'What do I need from my relationships that I\'m not getting?',
        'How do I show up in my relationships when I\'m at my best?',
        'What boundaries do I need to set or reinforce?',
        'What would a healthy relationship look like for me?'
      ];
      return relationshipPrompts[Math.floor(Math.random() * relationshipPrompts.length)];
    }
    
    // Job loss/unemployment prompts
    if (patterns.isJobLoss || concerns.includes('job_loss')) {
      const jobLossPrompts = [
        'What skills and strengths do I bring to potential employers?',
        'What kind of work environment would help me thrive?',
        'How can I take care of myself during this job search process?',
        'What support do I need right now as I look for work?'
      ];
      return jobLossPrompts[Math.floor(Math.random() * jobLossPrompts.length)];
    }
    
    // Work stress prompts
    if (patterns.isWorkplace || concerns.includes('work_stress')) {
      const workPrompts = [
        'What aspects of work drain me the most, and what energizes me?',
        'What boundaries between work and personal life do I need?',
        'If I could change one thing about my work situation, what would it be?',
        'What does work-life balance look like for me?'
      ];
      return workPrompts[Math.floor(Math.random() * workPrompts.length)];
    }
    
    // General emotional prompts
    const generalPrompts = [
      'What am I feeling right now, and why?',
      'What do I need most in this moment?',
      'What\'s one thing I can control today?',
      'What would taking care of myself look like today?'
    ];
    return generalPrompts[Math.floor(Math.random() * generalPrompts.length)];
  }

  // Extract goals and challenges from user messages
  private extractGoalsAndChallenges(state: UserState, message: string) {
    if (!state.goalsAndChallenges) {
      state.goalsAndChallenges = { statedGoals: [], currentChallenges: [], progress: [] };
    }
    
    // Goals: "I want to...", "I need to...", "trying to...", "goal is..."
    const goalPatterns = [
      /(?:want to|need to|trying to|goal is to|hoping to)\s+([^.,!?]+)/gi,
      /(?:get better at|improve|work on)\s+([^.,!?]+)/gi
    ];
    
    goalPatterns.forEach(pattern => {
      const matches = message.matchAll(pattern);
      for (const match of matches) {
        const goal = match[1].trim();
        if (goal && !state.goalsAndChallenges!.statedGoals!.includes(goal)) {
          state.goalsAndChallenges!.statedGoals!.push(goal);
        }
      }
    });
    
    // Challenges: "struggling with...", "having trouble with...", "can't handle..."
    const challengePatterns = [
      /(?:struggling with|having trouble with|can't handle|overwhelmed by)\s+([^.,!?]+)/gi,
      /(?:problem is|issue is|challenge is)\s+([^.,!?]+)/gi
    ];
    
    challengePatterns.forEach(pattern => {
      const matches = message.matchAll(pattern);
      for (const match of matches) {
        const challenge = match[1].trim();
        if (challenge && !state.goalsAndChallenges!.currentChallenges!.includes(challenge)) {
          state.goalsAndChallenges!.currentChallenges!.push(challenge);
        }
      }
    });
    
    // Progress: "feeling better", "helped", "working"
    if (/(?:feeling better|helped|is working|making progress)/i.test(message)) {
      state.goalsAndChallenges!.progress!.push(`Noted improvement: ${new Date().toLocaleDateString()}`);
    }
  }

  // Extract coping strategies
  private extractCopingStrategies(state: UserState, message: string) {
    if (!state.copingStrategies) {
      state.copingStrategies = { whatWorks: [], whatDoesntWork: [], willingToTry: [] };
    }
    
    // What works
    const worksPatterns = [
      /(?:helps when i|helps me when i|feel better when i|works for me to)\s+([^.,!?]+)/gi,
      /(?:exercise|meditation|journaling|prayer|talking to|music|walking|running|gym)/gi
    ];
    
    worksPatterns.forEach(pattern => {
      const matches = message.matchAll(pattern);
      for (const match of matches) {
        const strategy = match[1] || match[0];
        if (strategy && !state.copingStrategies!.whatWorks!.includes(strategy.trim())) {
          state.copingStrategies!.whatWorks!.push(strategy.trim());
        }
      }
    });
    
    // What doesn't work
    if (/(?:tried|doesn't help|doesn't work|makes it worse)/i.test(message)) {
      const notWorkingPattern = /(?:tried|doesn't help)\s+([^.,!?]+)\s+(?:but|and)/gi;
      const matches = message.matchAll(notWorkingPattern);
      for (const match of matches) {
        const strategy = match[1].trim();
        if (strategy && !state.copingStrategies!.whatDoesntWork!.includes(strategy)) {
          state.copingStrategies!.whatDoesntWork!.push(strategy);
        }
      }
    }
  }

  // Extract triggers and stressors
  private extractTriggersAndStressors(state: UserState, message: string) {
    if (!state.triggersAndStressors) {
      state.triggersAndStressors = { identified: [], patterns: [] };
    }
    
    // Triggers: "triggered by...", "sets me off", "makes me anxious"
    const triggerPatterns = [
      /(?:triggered by|sets me off|makes me anxious|stressed by|worried about)\s+([^.,!?]+)/gi
    ];
    
    triggerPatterns.forEach(pattern => {
      const matches = message.matchAll(pattern);
      for (const match of matches) {
        const trigger = match[1].trim();
        if (trigger && !state.triggersAndStressors!.identified!.includes(trigger)) {
          state.triggersAndStressors!.identified!.push(trigger);
        }
      }
    });
    
    // Patterns: "worse on...", "better when...", "always happens when..."
    const patternMatches = [
      /(?:worse on|worse during|worse when)\s+([^.,!?]+)/gi,
      /(?:better when|better after|improves when)\s+([^.,!?]+)/gi
    ];
    
    patternMatches.forEach(pattern => {
      const matches = message.matchAll(pattern);
      for (const match of matches) {
        const patternStr = match[0].trim();
        if (patternStr && !state.triggersAndStressors!.patterns!.includes(patternStr)) {
          state.triggersAndStressors!.patterns!.push(patternStr);
        }
      }
    });
  }

  // Extract support system details
  private extractSupportSystem(state: UserState, message: string) {
    if (!state.supportSystem) {
      state.supportSystem = {
        hasProfessionalSupport: false,
        supportPeople: [],
        supportGroups: [],
        barriers: []
      };
    }
    
    // Professional support
    if (/(?:therapist|counselor|psychiatrist|psychologist|doctor)/i.test(message)) {
      state.supportSystem.hasProfessionalSupport = true;
    }
    
    // Support people: "my friend", "my brother", "my mom", "talked to my..."
    const supportPeoplePattern = /(?:my|talked to my)\s+(friend|brother|sister|mom|dad|wife|girlfriend|boyfriend|partner|cousin|uncle|aunt)/gi;
    const matches = message.matchAll(supportPeoplePattern);
    for (const match of matches) {
      const person = match[1];
      if (person && !state.supportSystem.supportPeople!.includes(person)) {
        state.supportSystem.supportPeople!.push(person);
      }
    }
    
    // Support groups: "men's group", "church", "AA", "support group"
    if (/(?:men's group|church|support group|community group|bible study|aa|na)/i.test(message)) {
      const groupMatch = message.match(/(?:men's group|church|support group|community group|bible study|aa|na)/i);
      if (groupMatch && !state.supportSystem.supportGroups!.includes(groupMatch[0])) {
        state.supportSystem.supportGroups!.push(groupMatch[0]);
      }
    }
    
    // Barriers: "can't afford", "don't trust", "stigma", "too expensive"
    const barrierKeywords = ['can\'t afford', 'too expensive', 'don\'t trust', 'stigma', 'ashamed', 'embarrassed', 'no time', 'too busy'];
    barrierKeywords.forEach(barrier => {
      if (!state.supportSystem) {
        state.supportSystem = {
          hasProfessionalSupport: false,
          supportPeople: [],
          supportGroups: [],
          barriers: []
        };
      }
      if (!state.supportSystem.barriers) {
        state.supportSystem.barriers = [];
      }
      if (message.includes(barrier) && !state.supportSystem.barriers.includes(barrier)) {
        state.supportSystem.barriers.push(barrier);
      }
    });
  }

  // Extract therapeutic preferences
  private extractTherapeuticPreferences(state: UserState, message: string) {
    if (!state.therapeuticPreferences) {
      state.therapeuticPreferences = { approaches: [], avoidances: [], openTo: [] };
    }
    
    // Approaches they like: CBT, mindfulness, talk therapy, etc.
    const approaches = ['cbt', 'cognitive behavioral', 'mindfulness', 'meditation', 'talk therapy', 'emdr', 'dbt'];
    approaches.forEach(approach => {
      if (message.includes(approach)) {
        if (/(?:like|prefer|helps|works|enjoy)/i.test(message) && !state.therapeuticPreferences!.approaches!.includes(approach)) {
          state.therapeuticPreferences!.approaches!.push(approach);
        } else if (/(?:don't like|doesn't work|not for me|avoid)/i.test(message) && !state.therapeuticPreferences!.avoidances!.includes(approach)) {
          state.therapeuticPreferences!.avoidances!.push(approach);
        }
      }
    });
    
    // Open to trying
    if (/(?:willing to try|open to|might try|considering)/i.test(message)) {
      const openToPattern = /(?:willing to try|open to|might try|considering)\s+([^.,!?]+)/gi;
      const matches = message.matchAll(openToPattern);
      for (const match of matches) {
        const strategy = match[1].trim();
        if (strategy && !state.therapeuticPreferences!.openTo!.includes(strategy)) {
          state.therapeuticPreferences!.openTo!.push(strategy);
        }
      }
    }
  }

  // Extract cultural and religious considerations
  private extractCulturalConsiderations(state: UserState, message: string) {
    if (!state.culturalConsiderations) {
      state.culturalConsiderations = { culturalPractices: [], culturalIdentity: [], languagePreferences: [] };
    }
    
    // Religious beliefs
    const religions = ['christian', 'muslim', 'islam', 'spiritual', 'religious', 'faith', 'god'];
    religions.forEach(religion => {
      if (message.includes(religion)) {
        if (!state.culturalConsiderations) {
          state.culturalConsiderations = { culturalPractices: [], culturalIdentity: [], languagePreferences: [] };
        }
        state.culturalConsiderations.religiousBeliefs = religion;
      }
    });
    
    // Cultural practices
    const practices = ['prayer', 'meditation', 'church', 'mosque', 'temple', 'community gathering', 'family gathering'];
    practices.forEach(practice => {
      if (!state.culturalConsiderations) {
        state.culturalConsiderations = { culturalPractices: [], culturalIdentity: [], languagePreferences: [] };
      }
      if (!state.culturalConsiderations.culturalPractices) {
        state.culturalConsiderations.culturalPractices = [];
      }
      if (message.includes(practice) && !state.culturalConsiderations.culturalPractices.includes(practice)) {
        state.culturalConsiderations.culturalPractices.push(practice);
      }
    });
    
    // Cultural identity
    const identities = ['black', 'african american', 'caribbean', 'african', 'latino', 'hispanic', 'person of color'];
    identities.forEach(identity => {
      if (!state.culturalConsiderations) {
        state.culturalConsiderations = { culturalPractices: [], culturalIdentity: [], languagePreferences: [] };
      }
      if (!state.culturalConsiderations.culturalIdentity) {
        state.culturalConsiderations.culturalIdentity = [];
      }
      if (message.includes(identity) && !state.culturalConsiderations.culturalIdentity.includes(identity)) {
        state.culturalConsiderations.culturalIdentity.push(identity);
      }
    });
  }

  // Get or initialize conversation flow
  private getConversationFlow(userId: string): ConversationFlow {
    if (!this.conversationFlows.has(userId)) {
      this.conversationFlows.set(userId, {
        userId,
        currentStage: 'opening',
        topic: '',
        turnsInCurrentStage: 0,
        crisisLevel: 'none',
        crisisIndicators: [],
        lastStageChange: new Date().toISOString()
      });
    }
    return this.conversationFlows.get(userId)!;
  }

  // Determine conversation stage based on patterns and history
  private updateConversationStage(userId: string, userMessage: string, patterns: any, messageCount: number) {
    const flow = this.getConversationFlow(userId);
    flow.turnsInCurrentStage++;
    
    // Stage progression logic (check-in flow)
    if (messageCount === 1) {
      // First message - always start with opening/listening
      flow.currentStage = 'listening';
      flow.topic = this.identifyPrimaryTopic(patterns);
    } else if (flow.currentStage === 'listening' && flow.turnsInCurrentStage >= 2) {
      // After 2 turns of listening, move to clarifying
      flow.currentStage = 'clarifying';
      flow.turnsInCurrentStage = 0;
    } else if (flow.currentStage === 'clarifying' && flow.turnsInCurrentStage >= 1) {
      // After clarifying, provide education if relevant
      flow.currentStage = 'educating';
      flow.turnsInCurrentStage = 0;
    } else if (flow.currentStage === 'educating' && flow.turnsInCurrentStage >= 1) {
      // After education, move to suggestions
      flow.currentStage = 'suggesting';
      flow.turnsInCurrentStage = 0;
    } else if (flow.currentStage === 'suggesting' && flow.turnsInCurrentStage >= 2) {
      // After suggestions, get commitment
      flow.currentStage = 'committing';
      flow.turnsInCurrentStage = 0;
    }
    
    // Check if conversation is ending
    if (patterns.isConversationEnding) {
      flow.currentStage = 'closing';
    }
    
    flow.lastStageChange = new Date().toISOString();
  }

  // Identify primary topic from patterns
  private identifyPrimaryTopic(patterns: any): string {
    if (patterns.isCrisis) return 'crisis';
    if (patterns.isDepression) return 'depression';
    if (patterns.isAnxiety) return 'anxiety';
    if (patterns.isTrauma) return 'trauma';
    if (patterns.isRelationship) return 'relationships';
    if (patterns.isJobLoss) return 'job_loss';
    if (patterns.isWorkplace) return 'work_stress';
    return 'general_support';
  }

  // Get conversation stage guidance for AI
  private getStageGuidance(flow: ConversationFlow): string {
    const stageGuidance: { [key: string]: string } = {
      'opening': 'This is the first interaction. Ask an open-ended question to understand what they need.',
      'listening': 'Active listening phase. Validate their feelings and reflect back what you hear. Don\'t jump to solutions yet.',
      'clarifying': 'Ask 1-2 clarifying questions to better understand their situation. What\'s the context? How long has this been happening?',
      'educating': 'If appropriate, briefly normalize or provide psychoeducation about what they\'re experiencing. Keep it brief and relatable.',
      'suggesting': 'Offer 1-2 actionable suggestions based on what you know works for them. Be specific and practical.',
      'committing': 'Ask about next steps or what they might try. Get a soft commitment without pressure.',
      'closing': 'User is ending the conversation. Give a brief, warm closing. No new questions.'
    };
    
    return stageGuidance[flow.currentStage] || '';
  }

  // Crisis detection and progressive escalation
  private monitorCrisisLevel(userId: string, userMessage: string, patterns: any): CrisisMonitor {
    if (!this.crisisMonitors.has(userId)) {
      this.crisisMonitors.set(userId, {
        userId,
        indicators: [],
        escalationStage: 'validate',
        needsProfessional: false
      });
    }
    
    const monitor = this.crisisMonitors.get(userId)!;
    const lowerMessage = userMessage.toLowerCase();
    
    // Detect crisis indicators with severity levels
    const criticalIndicators = [
      // Category 1: Direct suicidal ideation
      'suicide', 'kill myself', 'end my life', 'end it all', 'don\'t want to live',
      'better off dead', 'no reason to live', 'want to die', 'wish i was dead',
      'going to kill myself', 'planning to kill myself',
      // Category 7: Preparation/Planning (HIGHEST RISK)
      'have a plan', 'set a date', 'wrote goodbye', 'saying goodbye',
      'final arrangements', 'gave away my things', 'this is my last day',
      // Category 12: Finality language
      'goodbye forever', 'this is goodbye', 'won\'t see me again', 'this is the end'
    ];
    
    const highIndicators = [
      // Category 2: Self-harm
      'self harm', 'hurt myself', 'cutting', 'harm myself',
      'thoughts of dying', 'suicidal', 'overdosed', 'burning myself',
      // Category 4: Burden beliefs (strong predictor)
      'better off without me', 'burden to everyone', 'nobody would miss me',
      'waste of space', 'everyone would be happier'
    ];
    
    const mediumIndicators = [
      // Category 3: Hopelessness
      'don\'t want to be here', 'can\'t go on', 'give up',
      'no hope', 'hopeless', 'worthless', 'burden', 'no way out',
      // Category 8: Passive ideation
      'hope i don\'t wake up', 'wish i would die', 'wouldn\'t mind if i died',
      // Category 6: Isolation
      'nobody cares', 'completely alone', 'nobody would notice'
    ];
    
    const lowIndicators = [
      'don\'t see the point', 'what\'s the point', 'nothing matters',
      'can\'t do this anymore'
    ];
    
    // Check for indicators and track
    criticalIndicators.forEach(indicator => {
      if (lowerMessage.includes(indicator)) {
        monitor.indicators.push({
          timestamp: new Date().toISOString(),
          severity: 'critical',
          indicator
        });
      }
    });
    
    highIndicators.forEach(indicator => {
      if (lowerMessage.includes(indicator)) {
        monitor.indicators.push({
          timestamp: new Date().toISOString(),
          severity: 'high',
          indicator
        });
      }
    });
    
    mediumIndicators.forEach(indicator => {
      if (lowerMessage.includes(indicator)) {
        monitor.indicators.push({
          timestamp: new Date().toISOString(),
          severity: 'medium',
          indicator
        });
      }
    });
    
    lowIndicators.forEach(indicator => {
      if (lowerMessage.includes(indicator)) {
        monitor.indicators.push({
          timestamp: new Date().toISOString(),
          severity: 'low',
          indicator
        });
      }
    });
    
    // Progressive escalation based on indicator count and severity
    const recentIndicators = monitor.indicators.filter(i => {
      const hourAgo = new Date(Date.now() - 60 * 60 * 1000);
      return new Date(i.timestamp) > hourAgo;
    });
    
    const hasCritical = recentIndicators.some(i => i.severity === 'critical');
    const hasHigh = recentIndicators.some(i => i.severity === 'high');
    const multipleIndicators = recentIndicators.length >= 3;
    
    // Update escalation stage
    if (hasCritical) {
      monitor.escalationStage = 'immediate';
      monitor.needsProfessional = true;
    } else if (hasHigh || multipleIndicators) {
      monitor.escalationStage = 'resources';
      monitor.needsProfessional = true;
    } else if (recentIndicators.length >= 2) {
      monitor.escalationStage = 'assess';
    } else if (recentIndicators.length >= 1) {
      monitor.escalationStage = 'validate';
    }
    
    return monitor;
  }

  // Get crisis-specific guidance for AI based on escalation stage
  private getCrisisGuidance(monitor: CrisisMonitor): string {
    const stageGuidance: { [key: string]: string } = {
      'validate': 'User mentioned concerning language. Validate their feelings without dismissing. Don\'t immediately jump to crisis resources unless they escalate.',
      'assess': 'Multiple concerning indicators detected. Gently assess: "Are you thinking about hurting yourself?" Be direct but compassionate.',
      'resources': 'High-risk indicators detected. After validating, provide crisis resources (988, Crisis Text Line). Encourage them to reach out.',
      'immediate': 'CRITICAL: Immediate crisis detected. Provide emergency resources NOW (988, 911). Be direct, caring, and urgent.'
    };
    
    return stageGuidance[monitor.escalationStage] || '';
  }

  // Build prioritized context window (optimized for Claude's 200K token limit)
  private buildPrioritizedContext(
    userId: string, 
    userMessage: string, 
    currentMessages: ChatMessage[], 
    patterns: any
  ): {
    userProfile: string;
    safetyNotes: string;
    knowledgeContext: string;
    recentConversation: string;
    sessionSummary: string;
  } {
    const userState = this.getUserState(userId);
    
    // 1. USER PROFILE (highest priority - comprehensive)
    let userProfile = '';
    
    // Check for recurring patterns
    const recurringTopics = this.getRecurringPatterns(userState);
    if (recurringTopics.length > 0) {
      userProfile += `âš ï¸ RECURRING PATTERN: User has mentioned ${recurringTopics.join(', ')} multiple times. This may be a core issue to address.\n`;
    }
    
    // Primary concerns
    if (userState.mentalHealthHistory?.primaryConcerns && userState.mentalHealthHistory.primaryConcerns.length > 0) {
      userProfile += `Primary concerns: ${userState.mentalHealthHistory.primaryConcerns.join(', ')}\n`;
    }
    
    // Goals and challenges
    if (userState.goalsAndChallenges?.statedGoals && userState.goalsAndChallenges.statedGoals.length > 0) {
      userProfile += `User goals: ${userState.goalsAndChallenges.statedGoals.join('; ')}\n`;
    }
    if (userState.goalsAndChallenges?.currentChallenges && userState.goalsAndChallenges.currentChallenges.length > 0) {
      userProfile += `Current challenges: ${userState.goalsAndChallenges.currentChallenges.join('; ')}\n`;
    }
    
    // Coping strategies
    if (userState.copingStrategies?.whatWorks && userState.copingStrategies.whatWorks.length > 0) {
      userProfile += `Effective coping: ${userState.copingStrategies.whatWorks.join(', ')}\n`;
    }
    if (userState.copingStrategies?.whatDoesntWork && userState.copingStrategies.whatDoesntWork.length > 0) {
      userProfile += `Ineffective strategies: ${userState.copingStrategies.whatDoesntWork.join(', ')}\n`;
    }
    
    // Triggers and patterns
    if (userState.triggersAndStressors?.identified && userState.triggersAndStressors.identified.length > 0) {
      userProfile += `Known triggers: ${userState.triggersAndStressors.identified.join(', ')}\n`;
    }
    if (userState.triggersAndStressors?.patterns && userState.triggersAndStressors.patterns.length > 0) {
      userProfile += `Patterns: ${userState.triggersAndStressors.patterns.join('; ')}\n`;
    }
    
    // Support system
    if (userState.supportSystem) {
      if (userState.supportSystem.hasProfessionalSupport) {
        userProfile += `Has professional mental health support\n`;
      }
      if (userState.supportSystem.supportPeople && userState.supportSystem.supportPeople.length > 0) {
        userProfile += `Support network: ${userState.supportSystem.supportPeople.join(', ')}\n`;
      }
      if (userState.supportSystem.barriers && userState.supportSystem.barriers.length > 0) {
        userProfile += `Barriers to care: ${userState.supportSystem.barriers.join(', ')}\n`;
      }
    }
    
    // Therapeutic preferences
    if (userState.therapeuticPreferences?.approaches && userState.therapeuticPreferences.approaches.length > 0) {
      userProfile += `Prefers: ${userState.therapeuticPreferences.approaches.join(', ')}\n`;
    }
    
    // Cultural considerations
    if (userState.culturalConsiderations) {
      if (userState.culturalConsiderations.religiousBeliefs) {
        userProfile += `Faith/spirituality: ${userState.culturalConsiderations.religiousBeliefs}\n`;
      }
      if (userState.culturalConsiderations.culturalIdentity && userState.culturalConsiderations.culturalIdentity.length > 0) {
        userProfile += `Cultural identity: ${userState.culturalConsiderations.culturalIdentity.join(', ')}\n`;
      }
      if (userState.culturalConsiderations.culturalPractices && userState.culturalConsiderations.culturalPractices.length > 0) {
        userProfile += `Cultural practices: ${userState.culturalConsiderations.culturalPractices.join(', ')}\n`;
      }
    }
    
    // Conversation summary
    if (userState.conversationSummary) {
      userProfile += `Session history: ${userState.conversationSummary}\n`;
    }
    
    // Integrate mood check-in data from Feeling Check-in feature
    const moodData = this.loadMoodCheckInData(userId);
    if (moodData && moodData.recentMoods.length > 0) {
      userProfile += `\nMood tracking data: Recent avg mood = ${moodData.avgMood.toFixed(1)}/10 (${moodData.recentMoods.length} check-ins)\n`;
    }
    
    // Personalized recommendations (shown occasionally, not every message)
    if (currentMessages.length > 0 && currentMessages.length % 15 === 0) {
      const recommendations = this.generatePersonalizedRecommendations(userState);
      if (recommendations) {
        userProfile += `\n--- PERSONALIZED RECOMMENDATIONS ---${recommendations}\n`;
      }
    }
    
    // 2. SAFETY FLAGS (critical priority)
    let safetyNotes = '';
    if (userState.safetyFlags?.crisisRisk) {
      safetyNotes += `âš ï¸ PREVIOUS CRISIS FLAG: User has mentioned crisis keywords before (${userState.safetyFlags.lastCrisisCheck}). Monitor closely.\n`;
    }
    
    // 3. RELEVANT RAG DOCUMENTS (context-specific)
    const relevantKnowledge = modernRAG.retrieveRelevantKnowledge(userMessage);
    const knowledgeContext = relevantKnowledge
      .map(k => `[${k.category}] ${k.content}`)
      .join('\n');
    
    // 4. RECENT CONVERSATION (last 3-5 exchanges in full detail)
    const recentMessages = currentMessages.slice(-this.MAX_RECENT_MESSAGES * 2); // user + assistant = 2 messages per exchange
    const recentConversation = recentMessages
      .map(msg => `${msg.role === 'user' ? 'User' : 'Amani'}: ${msg.content}`)
      .join('\n');
    
    // 5. PREVIOUS SESSION SUMMARY (compressed older conversations)
    let sessionSummary = '';
    if (currentMessages.length > this.MAX_RECENT_MESSAGES * 2) {
      const olderMessages = currentMessages.slice(0, -(this.MAX_RECENT_MESSAGES * 2));
      sessionSummary = this.summarizeOlderConversation(olderMessages);
    }
    
    return {
      userProfile,
      safetyNotes,
      knowledgeContext,
      recentConversation,
      sessionSummary
    };
  }

  // Summarize older conversation to save context space
  private summarizeOlderConversation(messages: ChatMessage[]): string {
    if (messages.length === 0) return '';
    
    // Extract key topics and concerns from older messages
    const topics = new Set<string>();
    const userMessages = messages.filter(m => m.role === 'user');
    
    userMessages.forEach(msg => {
      const patterns = modernRAG.detectPatterns(msg.content);
      if (patterns.isDepression) topics.add('depression');
      if (patterns.isAnxiety) topics.add('anxiety');
      if (patterns.isTrauma) topics.add('trauma');
      if (patterns.isRelationship) topics.add('relationship issues');
      if (patterns.isJobLoss) topics.add('job loss/unemployment');
      if (patterns.isWorkplace) topics.add('work stress');
      if (patterns.isCrisis) topics.add('CRISIS - previous episode');
    });
    
    const topicList = Array.from(topics).join(', ');
    return `Earlier in conversation, user discussed: ${topicList}. ${messages.length} previous exchanges.`;
  }

  // Update running user state summary (call this periodically, e.g., after every 10 messages)
  public updateConversationSummary(userId: string, currentMessages: ChatMessage[]) {
    const state = this.getUserState(userId);
    
    // Create a concise summary of the user's journey
    const concerns = state.mentalHealthHistory?.primaryConcerns || [];
    const messageCount = currentMessages.length;
    
    if (messageCount > 10) {
      const recentTopics = this.summarizeOlderConversation(currentMessages.slice(-20));
      state.conversationSummary = `User has been working on: ${concerns.join(', ')}. Recent focus: ${recentTopics}`;
      this.saveUserStates();
    }
  }

  // Check if user has previous session history
  private hasSessionHistory(userId: string): boolean {
    const state = this.getUserState(userId);
    return !!(state.mentalHealthHistory?.primaryConcerns && state.mentalHealthHistory.primaryConcerns.length > 0);
  }

  // Generate welcome back message for returning users
  private generateWelcomeBackMessage(userId: string): string | null {
    const state = this.getUserState(userId);
    
    // Don't show welcome back every time - only if it's been a while
    const lastUpdated = new Date(state.lastUpdated);
    const hoursSinceLastUpdate = (Date.now() - lastUpdated.getTime()) / (1000 * 60 * 60);
    
    // Only show if it's been more than 4 hours
    if (hoursSinceLastUpdate < 4) {
      return null;
    }
    
    const concerns = state.mentalHealthHistory?.primaryConcerns || [];
    const lastTopic = concerns[concerns.length - 1];
    
    // Check for recurring patterns (mentioned 3+ times)
    const recurringTopics = this.getRecurringPatterns(state);
    
    let welcomeMessage = "Welcome back! ";
    
    // Pattern recognition message
    if (recurringTopics.length > 0) {
      const topTopic = recurringTopics[0];
      welcomeMessage += `I notice we've talked about ${topTopic} a few times now. Want to dig deeper into that, or is there something else on your mind today?`;
    } else if (lastTopic) {
      // Reference last conversation
      welcomeMessage += `Last time we talked about ${lastTopic}. How have things been since then?`;
    } else {
      // Generic but warm
      welcomeMessage += "How are you doing today?";
    }
    
    return welcomeMessage;
  }

  // Identify recurring patterns across sessions
  private getRecurringPatterns(state: UserState): string[] {
    const concerns = state.mentalHealthHistory?.primaryConcerns || [];
    const recurring: string[] = [];
    
    // Count frequency of each concern (simple heuristic: if mentioned 3+ times)
    const concernCounts = new Map<string, number>();
    concerns.forEach(concern => {
      concernCounts.set(concern, (concernCounts.get(concern) || 0) + 1);
    });
    
    // Get concerns mentioned 3+ times
    concernCounts.forEach((count, concern) => {
      if (count >= 3) {
        recurring.push(concern);
      }
    });
    
    return recurring;
  }

  public async generateResponse(
    userMessage: string,
    userId: string = 'default',
    currentMessages: ChatMessage[] = []
  ): Promise<string> {
    // Start analytics session if not already started
    this.startAnalyticsSession(userId);
    
    // Check if this is a new session (first message)
    const isNewSession = currentMessages.length === 0;
    
    // Check for pending follow-ups first
    if (isNewSession) {
      const followUpMessage = this.checkForPendingFollowUps(userId);
      if (followUpMessage) {
        return followUpMessage;
      }

      // Check for weekly summary
      const weeklySummary = this.generateWeeklySummary(userId);
      if (weeklySummary) {
        return weeklySummary;
      }

      // Welcome back message for returning users
      if (this.hasSessionHistory(userId)) {
        const welcomeBack = this.generateWelcomeBackMessage(userId);
        if (welcomeBack) {
          return welcomeBack;
        }
      }
    }
    
    // Check for scope violations FIRST (diagnosis, medication, harmful content)
    const scopeViolation = this.checkScopeViolations(userMessage);
    if (scopeViolation) {
      return this.handleScopeViolation(scopeViolation);
    }
    
    // Always check for crisis second
    const patterns = modernRAG.detectPatterns(userMessage);
    if (patterns.isCrisis) {
      // Log crisis event
      const state = this.getUserState(userId);
      if (!state.safetyViolations) state.safetyViolations = [];
      state.safetyViolations.push({
        timestamp: new Date().toISOString(),
        type: 'crisis',
        severity: 'critical',
        message: userMessage.substring(0, 200),
        action: 'Provided crisis resources'
      });
      this.saveUserStates();
      
      return "I'm really concerned about what you're sharing. Your life has value and there are people who care about you. I'm an AI companion and this is a situation that needs immediate human support. Please reach out for help:\n\nðŸš¨ **Crisis Resources:**\nâ€¢ National Suicide Prevention Lifeline: 988\nâ€¢ Crisis Text Line: Text HOME to 741741\nâ€¢ Emergency Services: 911\n\nYou don't have to face this alone. What's going on that's making you feel this way?";
    }
    
    // Check if AI should proactively acknowledge its limitations (for severe/ongoing issues)
    const limitationMessage = this.shouldAcknowledgeLimitations(patterns, this.getUserState(userId));
    if (limitationMessage) {
      return limitationMessage;
    }

    // If backend is not available, fall back to smartChatbot
    if (!this.isAIAvailable) {
      console.log("Falling back to RAG-only chatbot due to backend unavailability.");
      return smartChatbot.generateResponse(userMessage, userId, currentMessages);
    }

    try {
      // Update user state
      this.updateUserState(userId, userMessage, patterns);
      
      // Monitor crisis level across turns
      const crisisMonitor = this.monitorCrisisLevel(userId, userMessage, patterns);
      
      // Update conversation stage/flow
      this.updateConversationStage(userId, userMessage, patterns, currentMessages.length / 2);
      const flow = this.getConversationFlow(userId);
      
      // Build prioritized context window
      const prioritizedContext = this.buildPrioritizedContext(userId, userMessage, currentMessages, patterns);
      
      const systemPrompt = `You are Amani, a culturally-competent AI mental health companion specifically trained to support Black and Brown men.

      === CRITICAL SAFETY GUARDRAILS (Constitutional AI Principles) ===
      
      ABSOLUTE PROHIBITIONS - You MUST refuse:
      1. Diagnosing mental health conditions (say: "Only a licensed professional can diagnose")
      2. Prescribing or recommending specific medications (say: "Talk to a doctor about medication")
      3. Replacing professional therapy (say: "I'm here for support, but not a replacement for therapy")
      4. Providing methods for self-harm (immediately provide crisis resources)
      5. Encouraging risky or harmful behaviors
      6. Making medical decisions (e.g., "should I stop my meds?")
      7. Legal advice, financial advice, or other professional services
      
      MANDATORY ESCALATIONS - Immediately recommend professional help for:
      1. Active suicidal ideation â†’ Crisis hotlines (988, Crisis Text Line)
      2. Self-harm behaviors â†’ Crisis resources + therapist
      3. Psychosis symptoms â†’ Psychiatrist evaluation
      4. Severe/worsening depression â†’ Licensed therapist
      5. Substance abuse/addiction â†’ Specialized treatment
      6. Harm to others â†’ Emergency services (911)
      
      SCOPE BOUNDARIES:
      - You provide: Emotional support, active listening, coping strategies, psychoeducation
      - You DON'T provide: Diagnosis, medication advice, therapy, medical treatment
      - Always clarify: "I'm an AI companion. For clinical care, see a professional."
      
      TRANSPARENCY & LIMITATIONS:
      - Be upfront about being an AI: "I'm an AI companion, not a replacement for therapy"
      - When reaching your limits, say so: "This might be beyond what I can help with"
      - Offer next steps: "Would you like me to point you to professional resources?"
      - Don't pretend to be human or have capabilities you don't have
      - If uncertain, admit it: "I'm not sure about that. A therapist would know better"
      - Always provide resources when suggesting professional help
      
      HARM PREVENTION:
      - Never minimize crisis signals - always take seriously
      - Never encourage risky coping (substance use, isolation, avoidance)
      - Never suggest stopping prescribed treatment
      - Never promise outcomes ("you'll be fine", "this will cure you")
      - Always provide resources when out of scope
      
      === CRITICAL CONTEXT INTERPRETATION RULES ===
      
      When users discuss relationships, finances, work, or life stress, interpret ambiguous words in their EMOTIONAL/PSYCHOLOGICAL context:
      
      AMBIGUOUS WORDS - EMOTIONAL INTERPRETATIONS:
      - "tired" = emotionally exhausted, burnt out, weary (NOT sleepy/physical fatigue)
      - "heavy" = emotional burden, psychological weight (NOT physical weight)
      - "drained" = emotionally depleted, psychologically exhausted (NOT physical energy)
      - "carrying" = bearing emotional/financial burden (NOT physical lifting)
      - "exhausted" = emotionally spent (NOT physically tired)
      - "weight" = emotional burden (NOT body weight)
      - "can't breathe" = feeling overwhelmed/trapped (NOT physical breathing problem)
      
      RESPONSE GUIDELINES FOR AMBIGUOUS LANGUAGE:
      1. NEVER suggest physical health interventions (sleep exercises, physical rest, breathing for sleep) unless user EXPLICITLY mentions:
         - "I can't sleep" / "insomnia"
         - "I'm physically tired"
         - Physical symptoms or asks about sleep/physical health
      
      2. When you encounter ambiguous language in emotional contexts, briefly acknowledge the emotional aspect:
         - "It sounds like you're feeling emotionally exhausted by this situation..."
         - "That's a heavy emotional burden to carry..."
         - "The mental weight of that must be draining..."
      
      3. STAY FOCUSED on emotional and psychological aspects - don't pivot to physical health
      
      4. If genuinely unclear, ask a BRIEF clarifying question before giving advice
      
      CORRECT vs INCORRECT INTERPRETATIONS:
      
      User: "I'm tired of my wife carrying me financially"
      âœ… CORRECT: Acknowledge emotional exhaustion, relationship stress, feelings of inadequacy, financial burden
      âŒ INCORRECT: Suggest sleep exercises, physical rest, or breathing for sleep
      
      User: "This burden is so heavy"
      âœ… CORRECT: Acknowledge emotional weight, validate psychological burden, discuss coping
      âŒ INCORRECT: Suggest physical exercises, weight management, or physical health interventions
      
      User: "I feel drained after these conversations"
      âœ… CORRECT: Acknowledge emotional depletion, validate relational exhaustion
      âŒ INCORRECT: Suggest energy drinks, physical rest, or sleep advice
      
      User: "I can't carry this anymore"
      âœ… CORRECT: Recognize feeling overwhelmed, emotional capacity limit, need for support
      âŒ INCORRECT: Suggest physical strength training or posture advice
      
      CORE PRINCIPLES:
      - Recognize intersectionality of race, masculinity, and mental health
      - Understand cultural stigma around seeking help - validate without judgment
      - Use culturally-relevant language and references naturally
      - Know when to escalate to human professionals
      - Balance empathy with actionable, practical advice
      - Acknowledge strength in seeking help

      CONVERSATION STYLE:
      - Start where the user is emotionally - meet them there
      - Use active listening: reflection, validation, clarifying questions
      - Ask clarifying questions BEFORE jumping to solutions
      - MAX 2 sentences, 30 words total unless crisis/complex issue
      - Talk naturally - like texting a trusted friend, not a therapist
      - NEVER use corporate therapy language: "safe space", "without judgment", "I'm here to listen"
      - NEVER repeat yourself. Build on what they said with NEW insights
      
      TONE ADJUSTMENT (based on emotional state):
      - Very negative/Crisis: More gentle, slower pace, validate heavily
      - Negative: Supportive and empathetic, ask clarifying questions
      - Neutral: Conversational and curious, explore deeper
      - Positive: Warm and encouraging, celebrate with them
      - Very positive: Match their energy, be excited for them
      
      PATTERN RECOGNITION:
      - If you see RECURRING PATTERN in user profile, gently acknowledge it
      - Example: "I notice work stress keeps coming up. Ready to tackle that head-on?"
      - Use patterns to suggest deeper work or professional support
      - Don't be preachy - be observant and curious
      - If MOOD ALERT (declining trend), check in: "You seem to be struggling more lately. What's changed?"
      - If POSITIVE TREND (improving), celebrate: "Things seem better! What's been helping?"
      
      PERSONALIZED RECOMMENDATIONS:
      - If you see PERSONALIZED RECOMMENDATIONS in user profile, reference them naturally
      - Suggest specific app features (Journal, Discussions, Resources) based on their needs
      - Recommend coping techniques they haven't tried yet
      - Connect them to community discussions on their topics
      - Suggest professional help appropriately (consider barriers they've mentioned)
      - Leverage what already works for them (e.g., "Since exercise helps you...")
      
      THERAPEUTIC TOOLS (Embed when appropriate):
      - If user is anxious RIGHT NOW: Suggest the breathing exercise provided
      - If user is panicking/overwhelmed (intensity 7+): Suggest the 5-4-3-2-1 grounding technique
      - If user is processing emotions: Suggest the journal prompt provided
      - If discussing mood patterns: Reference their mood tracking data if available
      - Always tie tools to their specific situation - don't just list techniques

      CULTURAL COMPETENCY:
      - Understand code-switching and cultural tax
      - Recognize racial trauma, microaggressions, discrimination
      - Be aware of disparities in mental health access
      - Respect cultural healing practices, spirituality, and community support
      - ONLY reference race/culture IF the user explicitly mentions it as a factor
      - Don't assume - ask about their experience

      SAFETY PROTOCOLS:
      - Crisis keywords (suicide, self-harm, "don't want to live"): Immediate crisis resources
      - Escalate to professionals for: severe depression, psychosis, ongoing trauma
      - Always provide hotline numbers for crisis situations

      SPECIFIC GUIDANCE:
      - Anxiety/racing thoughts: Grounding techniques (5-4-3-2-1, breathe, move)
      - Depression: Validate feelings, small actionable steps, professional help
      - Workplace issues: Practical boundaries, documentation, self-advocacy
      - Relationship problems: Communication, boundaries, respect
      - Job loss: Validate grief, practical next steps, financial resources
      - Discrimination/microaggressions: Validate experience, self-care, community

      CONVERSATION ENDINGS:
      - If they say thanks, feeling better, gotta go: SHORT closing ("Take care" or "I'm here when you need me")
      - Otherwise: 1 short, open-ended question

      --- CURRENT CONVERSATION STAGE ---
      ${this.getStageGuidance(flow)}
      Current stage: ${flow.currentStage} | Topic: ${flow.topic}

      ${this.getMoodTrendGuidance(this.getUserState(userId).lastMoodTrend)}

      ${crisisMonitor.indicators.length > 0 ? '--- CRISIS MONITORING ---\n' + this.getCrisisGuidance(crisisMonitor) + '\nRecent indicators: ' + crisisMonitor.indicators.slice(-3).map(i => i.indicator).join(', ') : ''}

      ${prioritizedContext.userProfile ? '--- USER PROFILE ---\n' + prioritizedContext.userProfile : ''}
      
      ${prioritizedContext.safetyNotes ? '--- SAFETY NOTES ---\n' + prioritizedContext.safetyNotes : ''}
      
      ${prioritizedContext.knowledgeContext ? '--- RELEVANT MENTAL HEALTH INFO ---\n' + prioritizedContext.knowledgeContext : ''}
      
      ${prioritizedContext.recentConversation ? '--- RECENT CONVERSATION (Last 5 exchanges) ---\n' + prioritizedContext.recentConversation : ''}
      
      ${prioritizedContext.sessionSummary ? '--- PREVIOUS SESSION SUMMARY ---\n' + prioritizedContext.sessionSummary : ''}
      
      ${this.getContextualTherapeuticTools(patterns, this.getUserState(userId).emotionalHistory?.slice(-1)[0])}

      Be real, culturally aware, and genuinely helpful. Keep it brief unless the situation demands more.`;

      // Get recent conversation for API call (only last 5 exchanges to save tokens)
      const recentHistory = currentMessages.slice(-this.MAX_RECENT_MESSAGES * 2);
      
      // Call backend proxy instead of direct API
      console.log(`ðŸ”— Calling backend at: ${this.backendUrl}/api/chat`);
      console.log(`ðŸ“¤ Sending message: ${userMessage.substring(0, 50)}...`);
      
      const response = await fetch(`${this.backendUrl}/api/chat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          userMessage,
          conversationHistory: recentHistory,
          systemPrompt
        })
      });

      console.log(`ðŸ“¡ Response status: ${response.status}`);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`âŒ Backend error response: ${errorText}`);
        throw new Error(`Backend proxy error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Backend proxy returned error');
      }

      const aiResponse = data.response;
      
      // Store conversation history for potential future use
      this.storeConversation(userId, userMessage, aiResponse);
      
      // Detect if user mentioned a future event worth following up on
      this.detectFollowUpOpportunity(userId, userMessage);
      
      // Update conversation summary periodically (every 10 messages)
      if (currentMessages.length > 0 && currentMessages.length % 10 === 0) {
        this.updateConversationSummary(userId, currentMessages);
      }
      
      // Process response and add AI reminder if needed
      let processedResponse = this.postProcessResponse(aiResponse, patterns, userMessage);
      
      // Check if breathing exercise would help
      const breathingRec = this.recommendBreathingExercise(patterns);
      if (breathingRec) {
        processedResponse += `\n\n**Quick suggestion**: ${breathingRec.reason}. Would you like me to guide you through a ${breathingRec.exerciseName}? Just say "yes" or "breathing exercise".`;
      }
      
      // Add AI reminder periodically
      if (this.needsAIReminder(userId, currentMessages.length)) {
        processedResponse += this.generateAIReminder(userId);
      }
      
      return processedResponse;
    } catch (error) {
      console.error("âŒ Error calling backend proxy:", error);
      
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      const errorStack = error instanceof Error ? error.stack : undefined;
      
      console.error("ðŸ” Error details:", {
        message: errorMessage,
        stack: errorStack,
        backendUrl: this.backendUrl,
        userMessage: userMessage.substring(0, 50) + '...'
      });
      
      // Test if it's a network connectivity issue
      try {
        const testResponse = await fetch(`${this.backendUrl}/health`);
        console.log(`ðŸ¥ Health check status: ${testResponse.status}`);
      } catch (healthError) {
        console.error("âŒ Health check also failed:", healthError);
      }
      
      // Fallback to smartChatbot if backend call fails
      console.log("ðŸ”„ Falling back to RAG-only chatbot due to backend error.");
      return smartChatbot.generateResponse(userMessage, userId, currentMessages);
    }
  }


  private postProcessResponse(response: string, patterns: any, userMessage: string = ''): string {
    // Remove any cultural references unless explicitly mentioned
    if (!this.hasCulturalContext(response)) {
      response = response.replace(/as a (black|person of color|man of color)/gi, '');
      response = response.replace(/in our communities/gi, '');
    }

    // Check if user is ending the conversation
    const isConversationEnding = this.isConversationEnding(userMessage, response);

    // Only add follow-up question if conversation isn't ending
    if (!response.includes('?') && !response.includes('!') && !isConversationEnding) {
      response += ' How does that feel to you?';
    }

    // Remove any "Remember" statements or heart emojis
    response = response.replace(/ðŸ’™|ðŸ’š|ðŸ’œ|â¤ï¸|ðŸ’–|ðŸ’•|ðŸ’—|ðŸ’˜|ðŸ’|ðŸ’ž|ðŸ’Ÿ|Remember/gi, '');

    return response.trim();
  }

  private isConversationEnding(userMessage: string, botResponse: string): boolean {
    const lowerUserMessage = userMessage.toLowerCase();
    const lowerBotResponse = botResponse.toLowerCase();
    
    // User closure indicators
    const userClosurePatterns = [
      /thank you.*feel.*better/,
      /thanks.*i.*feel.*better/,
      /i.*feel.*much.*better/,
      /i.*feel.*great/,
      /that.*helps.*a.*lot/,
      /i.*think.*i.*will.*take.*your.*advice/,
      /i.*will.*do.*that/,
      /sounds.*good.*thank.*you/,
      /perfect.*thank.*you/,
      /i.*ll.*keep.*you.*posted/,
      /i.*ll.*try.*that/,
      /feels.*great/,
      /goodbye/,
      /bye/,
      /talk.*to.*you.*later/,
      /see.*you.*later/,
      /have.*a.*good.*day/,
      /take.*care/
    ];
    
    // Bot closure indicators
    const botClosurePatterns = [
      /take.*care/,
      /i.*m.*here.*when.*you.*need.*me/,
      /you.*ve.*got.*this/,
      /proud.*of.*you/,
      /you.*re.*on.*the.*right.*track/
    ];
    
    // Check if user message indicates closure
    const userIndicatesEnding = userClosurePatterns.some(pattern => 
      pattern.test(lowerUserMessage)
    );
    
    // Check if bot response indicates closure
    const botIndicatesEnding = botClosurePatterns.some(pattern => 
      pattern.test(lowerBotResponse)
    );
    
    return userIndicatesEnding || botIndicatesEnding;
  }

  // Check if response has cultural context
  private hasCulturalContext(response: string): boolean {
    const culturalKeywords = [
      'as a black man', 'person of color', 'man of color', 'our communities',
      'in our culture', 'black community', 'people of color'
    ];
    return culturalKeywords.some(keyword => 
      response.toLowerCase().includes(keyword.toLowerCase())
    );
  }

  private storeConversation(userId: string, userMessage: string, assistantResponse: string) {
    if (!this.conversationHistory.has(userId)) {
      this.conversationHistory.set(userId, []);
    }
    const history = this.conversationHistory.get(userId)!;
    history.push({ role: 'user', content: userMessage, timestamp: new Date().toISOString() });
    history.push({ role: 'assistant', content: assistantResponse, timestamp: new Date().toISOString() });
  }

  // Recommend breathing exercise based on detected patterns
  private recommendBreathingExercise(patterns: any): { exercise: string; exerciseName: string; reason: string } | null {
    const recommendations = {
      'anxiety': {
        exercise: 'extended', // 3-6 breathing
        exerciseName: '3-6 breathing exercise',
        reason: 'Extended exhales calm your nervous system fast'
      },
      'panic': {
        exercise: 'physiological',
        exerciseName: 'physiological sigh',
        reason: 'This works in 30-60 seconds for immediate relief'
      },
      'stress': {
        exercise: 'box',
        exerciseName: 'box breathing',
        reason: 'Navy SEALs use this to stay calm under pressure'
      },
      'sleep': {
        exercise: 'fourSevenEight',
        exerciseName: '4-7-8 breathing',
        reason: 'The long exhale helps you fall asleep faster'
      },
      'overwhelm': {
        exercise: 'physiological',
        exerciseName: 'physiological sigh',
        reason: 'This is the fastest way to reduce overwhelm'
      },
      'anger': {
        exercise: 'box',
        exerciseName: 'box breathing',
        reason: 'This helps you regain control when emotions are high'
      }
    };

    // Check patterns and recommend appropriate exercise
    // PRIORITY ORDER: Crisis > Panic > Primary concerns > Secondary symptoms
    
    if (patterns.isCrisis) return recommendations.panic; // Crisis = immediate panic breathing
    
    // Primary mental health concerns (highest priority)
    if (patterns.isWorkplace || patterns.isJobLoss || patterns.isFinancial) return recommendations.stress;
    if (patterns.isAnger) return recommendations.anger;
    
    // Anxiety/panic states (unless already addressed by primary concern)
    if (patterns.isAnxiety && !patterns.isWorkplace && !patterns.isFinancial) return recommendations.anxiety;
    
    // NEVER suggest sleep breathing if emotional exhaustion is detected
    // Only suggest sleep breathing if EXPLICITLY about sleep/insomnia
    // Don't trigger on relationship fatigue, work burnout, or emotional exhaustion
    if (patterns.isSleep && 
        !patterns.isWorkplace && 
        !patterns.isRelationship && 
        !patterns.isFinancial && 
        !patterns.isEmotionallyExhausted) { // NEW: Block sleep suggestions for emotional exhaustion
      return recommendations.sleep;
    }
    
    // General emotional distress patterns
    if (patterns.isDepression || patterns.isLoneliness || patterns.isSelfEsteem) {
      return recommendations.overwhelm;
    }

    return null;
  }

  private recommendWorkout(patterns: any): { action: string; workoutType: string; reason: string; message: string } | null {
    const recommendations = {
      'stress': {
        action: 'SUGGEST_WORKOUT',
        workoutType: 'stress_relief',
        reason: 'Physical activity releases endorphins and reduces cortisol',
        message: "Stress can mess with your mind and body. A quick workout can help release tension. Want to do a 10-minute session?"
      },
      'anxiety': {
        action: 'SUGGEST_WORKOUT',
        workoutType: 'anxiety_relief',
        reason: 'Exercise helps regulate your nervous system and burns off anxious energy',
        message: "When anxiety hits, moving your body can help reset your nervous system. Ready for a quick workout to channel that energy?"
      },
      'anger': {
        action: 'SUGGEST_WORKOUT',
        workoutType: 'anger_management',
        reason: 'Physical exertion helps release built-up tension and anger',
        message: "I hear the frustration. Sometimes the best way to work through anger is to work it out physically. Want to channel that energy into a workout?"
      },
      'depression': {
        action: 'SUGGEST_WORKOUT',
        workoutType: 'mood_boost',
        reason: 'Exercise releases endorphins and can improve mood naturally',
        message: "When you're feeling down, movement can be powerful medicine. A short workout might help lift your spirits. Interested?"
      },
      'fatigue': {
        action: 'SUGGEST_WORKOUT',
        workoutType: 'energy_boost',
        reason: 'Light exercise can actually increase energy levels and combat fatigue',
        message: "I know you're feeling tired, but sometimes a light workout can actually give you more energy. Want to try a gentle session?"
      },
      'self_esteem': {
        action: 'SUGGEST_WORKOUT',
        workoutType: 'confidence_building',
        reason: 'Achieving fitness goals builds confidence and self-worth',
        message: "Building physical strength can also build mental strength. A workout might help you feel more capable and confident. Ready to try?"
      }
    };

    // Check patterns and recommend appropriate workout
    if (patterns.isWorkplace || patterns.isFinancial) return recommendations.stress;
    if (patterns.isAnxiety) return recommendations.anxiety;
    if (patterns.isAnger) return recommendations.anger;
    if (patterns.isDepression) return recommendations.depression;
    if (patterns.isFatigue) return recommendations.fatigue;
    if (patterns.isSelfEsteem) return recommendations.self_esteem;
    
    // General stress patterns
    if (patterns.isLoneliness || patterns.isOverwhelm) {
      return recommendations.stress;
    }

    return null;
  }
}

export const claudeEnhancedChatbot = new ClaudeEnhancedChatbotService();
